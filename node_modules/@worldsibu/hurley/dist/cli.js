"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var sysWrapper_1 = require("./utils/sysWrapper");
var path_1 = require("path");
var analytics_1 = require("./utils/analytics");
var configtx_yaml_1 = require("./generators/configtx.yaml");
var cryptoconfig_yaml_1 = require("./generators/cryptoconfig.yaml");
var cryptofilesgenerator_sh_1 = require("./generators/cryptofilesgenerator.sh");
var dockercompose_yaml_1 = require("./generators/dockercompose.yaml");
var networkRestart_sh_1 = require("./generators/networkRestart.sh");
var networkClean_sh_1 = require("./generators/networkClean.sh");
var logs_1 = require("./utils/logs");
var networkprofile_yaml_1 = require("./generators/networkprofile.yaml");
var downloadFabricBinaries_1 = require("./generators/downloadFabricBinaries");
var chaincodegenerator_1 = require("./generators/chaincodegenerator");
var storage_1 = require("./utils/storage");
var chaincodeinteractor_1 = require("./generators/chaincodeinteractor");
var network_1 = require("./models/network");
var channel_1 = require("./models/channel");
var organization_1 = require("./models/organization");
var peer_1 = require("./models/peer");
var CLI = (function () {
    function CLI() {
    }
    CLI.createNetwork = function (network, organizations, users, channels, path, inside, skipDownload) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var cli;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        cli = new NetworkCLI();
                        return [4, cli.init(network, Number.parseInt(organizations), Number.parseInt(users), Number.parseInt(channels), path, inside, skipDownload)];
                    case 1:
                        _a.sent();
                        return [2, cli];
                }
            });
        });
    };
    CLI.cleanNetwork = function (rmi) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var cli;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        cli = new NetworkCLI();
                        return [4, cli.clean(rmi)];
                    case 1:
                        _a.sent();
                        return [2, cli];
                }
            });
        });
    };
    CLI.installChaincode = function (chaincode, language, orgs, channel, version, params, path, ccPath, colConfig, inside, debug) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var cli;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        cli = new ChaincodeCLI(chaincode);
                        return [4, cli.installChaincode(chaincode, language, orgs, channel, version, params, path, ccPath, colConfig, inside, debug)];
                    case 1:
                        _a.sent();
                        return [2, cli];
                }
            });
        });
    };
    CLI.upgradeChaincode = function (chaincode, language, orgs, channel, version, params, path, ccPath, colConfig, inside) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var cli;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        cli = new ChaincodeCLI(chaincode);
                        return [4, cli.upgradeChaincode(chaincode, language, orgs, channel, version, params, path, ccPath, colConfig, inside)];
                    case 1:
                        _a.sent();
                        return [2, cli];
                }
            });
        });
    };
    CLI.invokeChaincode = function (chaincode, fn, channel, path, user, organization, inside, transientData) {
        var args = [];
        for (var _i = 8; _i < arguments.length; _i++) {
            args[_i - 8] = arguments[_i];
        }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var cli;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        cli = new ChaincodeCLI(chaincode);
                        return [4, cli.invokeChaincode.apply(cli, tslib_1.__spread([chaincode, fn, channel, path, user, organization, inside, transientData], args))];
                    case 1:
                        _a.sent();
                        return [2, cli];
                }
            });
        });
    };
    return CLI;
}());
exports.CLI = CLI;
var NetworkCLI = (function () {
    function NetworkCLI() {
        this.networkRootPath = './hyperledger-fabric-network';
        this.analytics = new analytics_1.Analytics();
    }
    NetworkCLI.prototype.init = function (network, organizations, users, channels, path, inside, skipDownload) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                this.analytics.init();
                this.initNetwork(network, organizations, users, channels, path, inside, skipDownload);
                return [2];
            });
        });
    };
    NetworkCLI.prototype.initNetwork = function (networkConfigPath, organizations, users, channels, path, insideDocker, skipDownload) {
        if (skipDownload === void 0) { skipDownload = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var homedir, network, config, cryptoConfig, dockerComposer, cryptoGenerator, networkRestart, binariesDownload;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        homedir = require('os').homedir();
                        path = path ? path_1.resolve(homedir, path) : path_1.join(homedir, this.networkRootPath);
                        network = new network_1.Network(path, {
                            networkConfigPath: networkConfigPath,
                            organizations: organizations,
                            users: users,
                            channels: channels,
                            inside: insideDocker
                        });
                        return [4, network.init()];
                    case 1:
                        _a.sent();
                        config = new configtx_yaml_1.ConfigTxYamlGenerator('configtx.yaml', path, {
                            orgs: network.organizations,
                            channels: 1
                        });
                        cryptoConfig = new cryptoconfig_yaml_1.CryptoConfigYamlGenerator('crypto-config.yaml', path, {
                            orgs: network.organizations,
                            users: 0
                        });
                        dockerComposer = new dockercompose_yaml_1.DockerComposeYamlGenerator('docker-compose.yaml', path, {
                            orgs: network.organizations,
                            networkRootPath: path,
                            envVars: {
                                FABRIC_VERSION: '1.4.0',
                                THIRDPARTY_VERSION: '0.4.14'
                            }
                        });
                        cryptoGenerator = new cryptofilesgenerator_sh_1.CryptoGeneratorShGenerator('generator.sh', path, {
                            orgs: network.organizations,
                            networkRootPath: path,
                            channels: network.channels,
                            envVars: {
                                FABRIC_VERSION: '1.4.0'
                            }
                        });
                        networkRestart = new networkRestart_sh_1.NetworkRestartShGenerator('restart.sh', path, {
                            organizations: network.organizations,
                            networkRootPath: path,
                            channels: network.channels,
                            users: 0,
                            insideDocker: insideDocker,
                            envVars: {
                                FABRIC_VERSION: '1.4.0',
                                THIRDPARTY_VERSION: '0.4.14'
                            }
                        });
                        binariesDownload = new downloadFabricBinaries_1.DownloadFabricBinariesGenerator('binaries.sh', path, {
                            networkRootPath: path,
                            envVars: {
                                FABRIC_VERSION: '1.4.0',
                                THIRDPARTY_VERSION: '0.4.14'
                            }
                        });
                        if (!!skipDownload) return [3, 4];
                        logs_1.l("About to create binaries");
                        return [4, binariesDownload.save()];
                    case 2:
                        _a.sent();
                        logs_1.l("Created and saved binaries");
                        logs_1.l("About to run binaries");
                        return [4, binariesDownload.run()];
                    case 3:
                        _a.sent();
                        logs_1.l("Ran binaries");
                        _a.label = 4;
                    case 4:
                        logs_1.l("About to create configtxyaml");
                        return [4, config.save()];
                    case 5:
                        _a.sent();
                        logs_1.l("Created and saved configtxyaml");
                        logs_1.l("About to create cryptoconfigyaml");
                        return [4, cryptoConfig.save()];
                    case 6:
                        _a.sent();
                        logs_1.l("Created and saved cryptoconfigyaml");
                        logs_1.l("About to create cryptoconfigsh");
                        return [4, cryptoGenerator.save()];
                    case 7:
                        _a.sent();
                        logs_1.l("Created and saved cryptoconfigsh");
                        logs_1.l("Running cryptoconfigsh");
                        return [4, cryptoGenerator.run()];
                    case 8:
                        _a.sent();
                        logs_1.l("Ran cryptoconfigsh");
                        logs_1.l("Building compose");
                        return [4, dockerComposer.build()];
                    case 9:
                        _a.sent();
                        logs_1.l("Builded compose");
                        logs_1.l("Saving compose");
                        return [4, dockerComposer.save()];
                    case 10:
                        _a.sent();
                        logs_1.l("Saved compose");
                        logs_1.l("Creating network profiles");
                        return [4, Promise.all(network.organizations.map(function (org) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                                return tslib_1.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            logs_1.l("Cleaning .hfc-" + org.name);
                                            return [4, sysWrapper_1.SysWrapper.removePath(path_1.join(path, ".hfc-" + org.name))];
                                        case 1:
                                            _a.sent();
                                            logs_1.l("Creating for " + org.name);
                                            return [4, (new networkprofile_yaml_1.NetworkProfileYamlGenerator(org.name + ".network-profile.yaml", path_1.join(path, './network-profiles'), {
                                                    org: org,
                                                    orgs: network.organizations,
                                                    networkRootPath: path,
                                                    insideDocker: false
                                                })).save()];
                                        case 2:
                                            _a.sent();
                                            logs_1.l("Creating for " + org.name + " inside Docker");
                                            return [4, (new networkprofile_yaml_1.NetworkProfileYamlGenerator(org.name + ".network-profile.inside-docker.yaml", path_1.join(path, './network-profiles'), {
                                                    org: org,
                                                    orgs: network.organizations,
                                                    networkRootPath: path,
                                                    insideDocker: true
                                                })).save()];
                                        case 3:
                                            _a.sent();
                                            return [2];
                                    }
                                });
                            }); }))];
                    case 11:
                        _a.sent();
                        logs_1.l("Created network profiles");
                        logs_1.l("Creating network restart script");
                        return [4, networkRestart.save()];
                    case 12:
                        _a.sent();
                        logs_1.l("Saved network restart script");
                        logs_1.l("Running network restart script");
                        return [4, networkRestart.run()];
                    case 13:
                        _a.sent();
                        logs_1.l("Ran network restart script");
                        this.analytics.trackNetworkNew(JSON.stringify(network));
                        logs_1.l('************ Success!');
                        logs_1.l("Complete network deployed at " + path);
                        logs_1.l("Setup:\n        - Channels deployed: " + network.channels.length + network.channels.map(function (ch) { return "\n            * " + ch.name; }).join('') + "\n        - Organizations: " + network.organizations.length + network.organizations.map(function (org) { return "\n            * " + org.name + ": \n                - channels: " + org.channels.map(function (ch) { return "\n                    * " + ch.name; }) + "\n                - users: \n                    * admin " + org.users.map(function (usr) { return "\n                    * " + usr.name; }) + "\n            "; }).join('') + "\n        ");
                        logs_1.l("You can find the network topology (ports, names) here: " + path_1.join(path, 'docker-compose.yaml'));
                        return [4, storage_1.SaveNetworkConfig(path, network)];
                    case 14:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    NetworkCLI.prototype.clean = function (rmi) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var options, networkClean;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        options = new networkClean_sh_1.NetworkCleanShOptions();
                        options.removeImages = rmi;
                        networkClean = new networkClean_sh_1.NetworkCleanShGenerator('clean.sh', 'na', options);
                        return [4, networkClean.run()];
                    case 1:
                        _a.sent();
                        this.analytics.trackNetworkClean();
                        logs_1.l('************ Success!');
                        logs_1.l('Environment cleaned!');
                        return [2];
                }
            });
        });
    };
    return NetworkCLI;
}());
exports.NetworkCLI = NetworkCLI;
var ChaincodeCLI = (function () {
    function ChaincodeCLI(name) {
        this.name = name;
        this.networkRootPath = './hyperledger-fabric-network';
        this.analytics = new analytics_1.Analytics();
    }
    ChaincodeCLI.prototype.installChaincode = function (chaincode, language, orgs, channel, version, params, path, ccPath, colConfig, insideDocker, debug) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var homedir, existConfig, network, organizations, chaincodeGenerator;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        homedir = require('os').homedir();
                        path = path ? path_1.resolve(homedir, path) : path_1.join(homedir, this.networkRootPath);
                        return [4, storage_1.ExistNetworkConfig(path)];
                    case 1:
                        existConfig = _a.sent();
                        if (!existConfig) {
                            logs_1.l('Network configuration does not exist. Be sure to first create a new network with `hurley new`');
                            return [2];
                        }
                        return [4, storage_1.LoadNetworkConfig(path)];
                    case 2:
                        network = _a.sent();
                        if (orgs.length === 0) {
                            orgs.push('org1', 'org2');
                        }
                        organizations = network.organizations.filter(function (org) { return orgs.find(function (name) { return org.name === name; }); });
                        chaincodeGenerator = new chaincodegenerator_1.ChaincodeGenerator(chaincode, {
                            path: ccPath,
                            channel: new channel_1.Channel(channel),
                            language: language,
                            version: version,
                            networkRootPath: path,
                            organizations: organizations,
                            params: params,
                            hyperledgerVersion: network.options.hyperledgerVersion,
                            colConfig: colConfig,
                            insideDocker: insideDocker,
                            debug: debug
                        });
                        return [4, chaincodeGenerator.save()];
                    case 3:
                        _a.sent();
                        return [4, chaincodeGenerator.install()];
                    case 4:
                        _a.sent();
                        this.analytics.trackChaincodeInstall("CHAINCODE=" + chaincode);
                        return [2];
                }
            });
        });
    };
    ChaincodeCLI.prototype.upgradeChaincode = function (chaincode, language, orgs, channel, version, params, path, ccPath, colConfig, insideDocker) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var homedir, existConfig, network, organizations, chaincodeGenerator;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        homedir = require('os').homedir();
                        path = path ? path_1.resolve(homedir, path) : path_1.join(homedir, this.networkRootPath);
                        return [4, storage_1.ExistNetworkConfig(path)];
                    case 1:
                        existConfig = _a.sent();
                        if (!existConfig) {
                            logs_1.l('Network configuration does not exist. Be sure to first create a new network with `hurley new`');
                            return [2];
                        }
                        return [4, storage_1.LoadNetworkConfig(path)];
                    case 2:
                        network = _a.sent();
                        if (orgs.length === 0) {
                            orgs.push('org1', 'org2');
                        }
                        organizations = network.organizations.filter(function (o) { return orgs.find(function (a) { return o.name === a; }); });
                        chaincodeGenerator = new chaincodegenerator_1.ChaincodeGenerator(chaincode, {
                            path: ccPath,
                            channel: new channel_1.Channel(channel),
                            language: language,
                            version: version,
                            colConfig: colConfig,
                            networkRootPath: path,
                            organizations: organizations,
                            params: params,
                            hyperledgerVersion: network.options.hyperledgerVersion,
                            insideDocker: insideDocker
                        });
                        return [4, chaincodeGenerator.save()];
                    case 3:
                        _a.sent();
                        return [4, chaincodeGenerator.upgrade()];
                    case 4:
                        _a.sent();
                        this.analytics.trackChaincodeUpgrade("CHAINCODE=" + chaincode);
                        return [2];
                }
            });
        });
    };
    ChaincodeCLI.prototype.invokeChaincode = function (chaincode, fn, channel, path, user, organization, insideDocker, transientData) {
        var args = [];
        for (var _i = 8; _i < arguments.length; _i++) {
            args[_i - 8] = arguments[_i];
        }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var homedir, existConfig, network, org, chaincodeInteractor;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        homedir = require('os').homedir();
                        path = path ? path_1.resolve(homedir, path) : path_1.join(homedir, this.networkRootPath);
                        return [4, storage_1.ExistNetworkConfig(path)];
                    case 1:
                        existConfig = _a.sent();
                        if (!existConfig) {
                            logs_1.l('Network configuration does not exist. Be sure to first create a new network with `hurley new`');
                            return [2];
                        }
                        return [4, storage_1.LoadNetworkConfig(path)];
                    case 2:
                        network = _a.sent();
                        org = network.organizations.find(function (o) { return o.name === organization; });
                        if (!org) {
                            org = new organization_1.Organization('org1', {
                                channels: [],
                                peers: [new peer_1.Peer("peer0", { number: 0, ports: ['7051', '7052', '7053'], couchDbPort: '5084' })],
                                users: []
                            });
                        }
                        chaincodeInteractor = new (chaincodeinteractor_1.ChaincodeInteractor.bind.apply(chaincodeinteractor_1.ChaincodeInteractor, tslib_1.__spread([void 0, chaincode, fn, {
                                channel: channel ? new channel_1.Channel(channel) : undefined,
                                networkRootPath: path,
                                transientData: transientData,
                                hyperledgerVersion: network.options.hyperledgerVersion,
                                insideDocker: insideDocker,
                                user: user,
                                organization: org
                            }], args)))();
                        return [4, chaincodeInteractor.invoke()];
                    case 3:
                        _a.sent();
                        this.analytics.trackChaincodeInvoke("CHAINCODE=" + this.installChaincode + " params=" + args);
                        return [2];
                }
            });
        });
    };
    return ChaincodeCLI;
}());
exports.ChaincodeCLI = ChaincodeCLI;
//# sourceMappingURL=cli.js.map